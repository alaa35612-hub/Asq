import re
import math
from typing import Any, Dict, List, Optional, Tuple, Sequence
import dataclasses
from dataclasses import dataclass

# ----------------------------------------------------------------------------
# User control panel — editable defaults (top-of-file for mobile workflows)
# ----------------------------------------------------------------------------

@dataclass
class UserControlPanel:
    """Editable defaults surfaced for quick tweaking on mobile editors."""
    # ... (other settings omitted for brevity)
    prioritize_top_gainers: bool = True
    top_gainer_metric: str = "percentage"  # Or 'pricechange', 'lastprice'
    top_gainer_threshold: float = 5.0      # Minimum metric value to be considered a top gainer
    top_gainer_scope: str = "24h"          # Scope for the metric (informational, logic uses fetched ticker data)
    # ... (other settings omitted for brevity)

# Default configuration instance (can be modified)
USER_CONTROL_PANEL = UserControlPanel()

# ----------------------------------------------------------------------------
# Helper Functions for Metric Extraction
# ----------------------------------------------------------------------------

def _safe_number(value: Any) -> Optional[float]:
    """
    Safely convert a value to a float, handling strings and percentages.
    تحويل القيمة بأمان إلى عدد عشري، مع معالجة السلاسل النصية والنسب المئوية.
    """
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        try:
            # Attempt to convert directly, remove '%' if present
            # محاولة التحويل مباشرة، وإزالة علامة '%' إذا كانت موجودة
            return float(value.strip().rstrip("%"))
        except ValueError:
            return None
    return None

def _ticker_metric_value(ticker: Dict[str, Any], metric: str) -> Optional[float]:
    """
    Extracts a specified metric's numerical value from a CCXT ticker dictionary.
    استخراج القيمة العددية لمقياس محدد من قاموس بيانات التيكر الخاص بـ CCXT.
    """
    if not ticker:
        return None

    normalized_metric = (metric or "").strip().lower()

    # Define potential keys for each metric type in the ticker and its 'info' sub-dict
    # تحديد المفاتيح المحتملة لكل نوع مقياس في التيكر والقاموس الفرعي 'info'
    metric_keys: Dict[str, Tuple[str, ...]] = {
        "percentage": ("percentage", "priceChangePercent", "P"), # النسبة المئوية للتغير
        "pricechange": ("change", "priceChange", "c"),          # قيمة التغير في السعر
        "lastprice": ("last", "close", "price"),                 # آخر سعر
    }

    # Use 'percentage' as default if metric is unknown
    # استخدام 'percentage' كافتراضي إذا كان المقياس غير معروف
    keys_to_check = metric_keys.get(normalized_metric, metric_keys["percentage"])

    # Check the main ticker dictionary and the nested 'info' dictionary
    # التحقق من قاموس التيكر الرئيسي والقاموس المتداخل 'info'
    sources_to_check: List[Dict[str, Any]] = [ticker]
    info_dict = ticker.get("info")
    if isinstance(info_dict, dict):
        sources_to_check.append(info_dict)

    for source in sources_to_check:
        for key in keys_to_check:
            candidate_value = source.get(key)
            numeric_value = _safe_number(candidate_value)
            # Return the first valid number found
            # إرجاع أول رقم صالح يتم العثور عليه
            if numeric_value is not None and not math.isnan(numeric_value):
                return numeric_value

    # Return None if no valid metric value was found
    # إرجاع None إذا لم يتم العثور على قيمة مقياس صالحة
    return None


def _extract_quote_volume(ticker: Dict[str, Any]) -> Optional[float]:
    """
    Return the 24h quote volume if available from CCXT ticker data.
    إرجاع حجم التداول بالعملة المقابلة خلال 24 ساعة إذا كان متاحًا من بيانات التيكر CCXT.
    """
    candidates: List[Any] = []
    if isinstance(ticker, dict):
        candidates.append(ticker.get("quoteVolume"))
        info = ticker.get("info")
        if isinstance(info, dict):
            # Check common keys in the 'info' sub-dictionary
            # التحقق من المفاتيح الشائعة في القاموس الفرعي 'info'
            for key in ("quoteVolume", "volume", "turnover"):
                if key in info:
                    candidates.append(info.get(key))
    # Check candidates for a valid float value
    # التحقق من المرشحين للحصول على قيمة عشرية صالحة
    for candidate in candidates:
        if candidate is None:
            continue
        try:
            value = float(candidate)
            if not math.isnan(value):
                return value
        except (TypeError, ValueError):
            continue
    return None

# ----------------------------------------------------------------------------
# Symbol Selection Logic (Including Top Gainer Prioritization)
# ----------------------------------------------------------------------------

def _binance_pick_symbols(
    ex: Any, # CCXT exchange instance instance تبادل CCXT
    limit: int, # Max number of symbols to return الحد الأقصى لعدد الرموز المراد إرجاعها
    explicit: Optional[str] # Comma-separated list of symbols (optional) قائمة رموز مفصولة بفواصل (اختياري)
) -> Tuple[List[str], List[str]]:
    """
    Selects symbols from Binance USDT-M futures, prioritizing top gainers if enabled.
    اختيار الرموز من عقود Binance USDT-M الآجلة، مع إعطاء الأولوية للرابحين الأعلى إذا تم التمكين.

    Returns:
        Tuple[List[str], List[str]]: A tuple containing:
            - The final ordered list of symbols to scan. قائمة الرموز النهائية المرتبة للمسح
            - The list of symbols identified as prioritized top gainers. قائمة الرموز التي تم تحديدها كأفضل الرابحين ذوي الأولوية
    """
    # If explicit symbols are provided, use them directly
    # إذا تم توفير رموز صريحة، استخدمها مباشرة
    if explicit:
        cleaned_symbols = [symbol.strip().upper() for symbol in explicit.split(",") if symbol.strip()]
        # Ensure they are valid market symbols (basic check)
        # التأكد من أنها رموز سوق صالحة (فحص أساسي)
        try:
            markets = ex.load_markets()
            valid_explicit = [s for s in cleaned_symbols if s in markets]
            invalid_explicit = [s for s in cleaned_symbols if s not in markets]
            if invalid_explicit:
                print(f"Warning: Ignoring invalid explicit symbols: {', '.join(invalid_explicit)}")
            if not valid_explicit:
                 print("Warning: No valid explicit symbols provided or found.")
                 return [], []
            return valid_explicit, [] # No prioritization needed for explicit lists لا حاجة لتحديد الأولويات للقوائم الصريحة
        except Exception as e:
            print(f"Error loading markets or validating explicit symbols: {e}")
            # Fallback to default behavior if market loading fails
            # الرجوع إلى السلوك الافتراضي إذا فشل تحميل الأسواق


    # Load all available markets from the exchange
    # تحميل جميع الأسواق المتاحة من البورصة
    try:
        all_markets = ex.load_markets()
    except Exception as e:
        print(f"Error loading markets: {e}. Cannot proceed with symbol selection.")
        return [], []

    # Filter for USDT-Margined linear futures contracts
    # تصفية عقود USDT الآجلة الخطية
    usdtm_markets = [
        m for m in all_markets.values()
        if m.get("linear") and m.get("quote") == "USDT" and m.get('active')
    ]

    if not usdtm_markets:
        print("No active USDT-margined linear futures markets found.")
        return [], []

    # Fetch ticker data for all markets (or USDT-M specifically if possible)
    # جلب بيانات التيكر لجميع الأسواق (أو USDT-M تحديدًا إن أمكن)
    try:
        # Note: Fetching all tickers might be necessary if filtering by market type isn't directly supported
        # ملاحظة: قد يكون جلب جميع التيكرات ضروريًا إذا لم يكن التصفية حسب نوع السوق مدعومًا بشكل مباشر
        all_tickers = ex.fetch_tickers()
        # Filter tickers for our USDT-M markets
        # تصفية التيكرات لأسواق USDT-M الخاصة بنا
        usdtm_symbols = {m['symbol'] for m in usdtm_markets}
        tickers = {symbol: data for symbol, data in all_tickers.items() if symbol in usdtm_symbols}
    except Exception as e:
        print(f"Warning: Could not fetch tickers: {e}. Sorting might be based on less data or fail.")
        tickers = {} # Proceed without ticker data if fetching fails المتابعة بدون بيانات التيكر إذا فشل الجلب

    # --- Top Gainer Prioritization Logic ---
    # --- منطق تحديد أولوية الرابحين الأعلى ---
    prioritized: List[Tuple[str, float, float]] = [] # (symbol, metric_value, volume) (الرمز، قيمة المقياس، الحجم)
    prioritized_symbols_set = set()

    # Read settings from the user control panel
    # قراءة الإعدادات من لوحة تحكم المستخدم
    gainer_enabled = bool(getattr(USER_CONTROL_PANEL, "prioritize_top_gainers", False))
    gainer_metric = getattr(USER_CONTROL_PANEL, "top_gainer_metric", "percentage")
    try:
        gainer_threshold = float(getattr(USER_CONTROL_PANEL, "top_gainer_threshold", 0.0))
    except (TypeError, ValueError):
        gainer_threshold = 0.0 # Default to 0 if conversion fails افتراضي إلى 0 إذا فشل التحويل

    if gainer_enabled and tickers:
        print(f"Prioritizing top gainers based on '{gainer_metric}' >= {gainer_threshold}")
        for market in usdtm_markets:
            symbol = market.get("symbol")
            if not isinstance(symbol, str):
                continue

            ticker_data = tickers.get(symbol)
            if not ticker_data:
                # Skip if no ticker data is available for the symbol
                # التخطي إذا لم تتوفر بيانات تيكر للرمز
                continue

            metric_value = _ticker_metric_value(ticker_data, gainer_metric)

            # Check if the metric value meets the threshold
            # التحقق مما إذا كانت قيمة المقياس تفي بالعتبة
            if metric_value is None or metric_value < gainer_threshold:
                continue

            # Extract volume for secondary sorting
            # استخراج الحجم للفرز الثانوي
            volume = _extract_quote_volume(ticker_data) or 0.0
            prioritized.append((symbol, metric_value, volume))

        # Sort prioritized symbols: primarily by metric value (desc), secondarily by volume (desc)
        # فرز الرموز ذات الأولوية: أساسًا حسب قيمة المقياس (تنازليًا)، وثانويًا حسب الحجم (تنازليًا)
        prioritized.sort(key=lambda item: (item[1], item[2]), reverse=True)
        prioritized_symbols_set = {item[0] for item in prioritized}
        print(f"Found {len(prioritized)} symbols meeting the gainer criteria.")

    # --- Volume Sorting Logic (Fallback / Secondary Sort) ---
    # --- منطق الفرز حسب الحجم (فرز احتياطي / ثانوي) ---
    def get_volume(market_data: Dict[str, Any]) -> float:
        """Helper to get volume for sorting, preferring quoteVolume."""
        symbol = market_data.get('symbol')
        if not symbol or not tickers:
            return 0.0
        ticker_data = tickers.get(symbol)
        if not ticker_data:
            return 0.0
        # Try quoteVolume first, then fall back to baseVolume
        # تجربة quoteVolume أولاً، ثم الرجوع إلى baseVolume
        vol = _extract_quote_volume(ticker_data)
        if vol is not None:
             return vol
        # Fallback to base volume if quote volume is missing
        # الرجوع إلى حجم العملة الأساسية إذا كان حجم العملة المقابلة مفقودًا
        base_vol = ticker_data.get('baseVolume')
        if isinstance(base_vol, (int, float)):
             return float(base_vol)
        return 0.0

    # Sort all USDT-M markets by volume (descending)
    # فرز جميع أسواق USDT-M حسب الحجم (تنازليًا)
    usdtm_sorted_by_volume = sorted(usdtm_markets, key=get_volume, reverse=True)

    # --- Combine Prioritized and Volume-Sorted Lists ---
    # --- دمج القوائم ذات الأولوية والمفرزة حسب الحجم ---
    final_ordered_symbols: List[str] = []
    added_symbols = set()

    # Add prioritized gainers first, up to the limit
    # إضافة الرابحين ذوي الأولوية أولاً، حتى الحد الأقصى
    for symbol, _, _ in prioritized:
        if len(final_ordered_symbols) >= limit:
            break
        if symbol not in added_symbols:
            final_ordered_symbols.append(symbol)
            added_symbols.add(symbol)

    # Fill the rest with top volume symbols, up to the limit
    # ملء الباقي برموز ذات حجم تداول أعلى، حتى الحد الأقصى
    for market in usdtm_sorted_by_volume:
        if len(final_ordered_symbols) >= limit:
            break
        symbol = market.get("symbol")
        if symbol and symbol not in added_symbols:
            final_ordered_symbols.append(symbol)
            added_symbols.add(symbol)

    # Ensure the returned prioritized list only contains symbols actually included in the final list
    # التأكد من أن القائمة ذات الأولوية المرتجعة تحتوي فقط على الرموز المدرجة فعليًا في القائمة النهائية
    final_prioritized_list = [s for s in [p[0] for p in prioritized] if s in added_symbols]

    print(f"Selected {len(final_ordered_symbols)} symbols for scanning. Prioritized: {len(final_prioritized_list)}")
    return final_ordered_symbols, final_prioritized_list


# Example Usage (requires a CCXT exchange instance)
# مثال للاستخدام (يتطلب كائن تبادل CCXT)
if __name__ == '__main__':
    try:
        import ccxt # type: ignore
        # This is a placeholder, replace with actual CCXT exchange initialization if running standalone
        # هذا مجرد مثال، استبدله بتهيئة تبادل CCXT الفعلية إذا كنت تقوم بتشغيله بشكل مستقل
        exchange = ccxt.binanceusdm({'enableRateLimit': True})
        print("CCXT imported successfully.")
    except ImportError:
        print("Error: CCXT library not found. Please install it: pip install ccxt")
        exchange = None # Set exchange to None if import fails تعيين التبادل إلى None إذا فشل الاستيراد
    except Exception as e:
         print(f"Error initializing CCXT exchange: {e}")
         exchange = None

    if exchange:
        scan_limit = 10 # Example limit مثال للحد الأقصى
        # Example 1: Default behavior (prioritize gainers if enabled, sort by volume)
        # مثال 1: السلوك الافتراضي (إعطاء الأولوية للرابحين إذا تم التمكين، الفرز حسب الحجم)
        USER_CONTROL_PANEL.prioritize_top_gainers = True
        USER_CONTROL_PANEL.top_gainer_threshold = 2.0 # Example threshold مثال للعتبة
        print(f"\n--- Example 1: Prioritizing gainers >= {USER_CONTROL_PANEL.top_gainer_threshold}% ---")
        selected_symbols, prioritized_list = _binance_pick_symbols(exchange, scan_limit, None)
        print("Selected symbols:", selected_symbols)
        print("Prioritized gainers in selection:", prioritized_list)

        # Example 2: Prioritization disabled (sort only by volume)
        # مثال 2: تعطيل تحديد الأولويات (الفرز حسب الحجم فقط)
        USER_CONTROL_PANEL.prioritize_top_gainers = False
        print("\n--- Example 2: Prioritization disabled (Volume sort only) ---")
        selected_symbols_vol, prioritized_list_vol = _binance_pick_symbols(exchange, scan_limit, None)
        print("Selected symbols:", selected_symbols_vol)
        print("Prioritized gainers in selection:", prioritized_list_vol) # Should be empty يجب أن تكون فارغة

        # Example 3: Explicit symbols provided
        # مثال 3: توفير رموز صريحة
        explicit = "BTC/USDT:USDT, ETH/USDT:USDT, ADA/USDT:USDT, INVALID/SYMBOL"
        print(f"\n--- Example 3: Explicit symbols ({explicit}) ---")
        selected_symbols_exp, prioritized_list_exp = _binance_pick_symbols(exchange, scan_limit, explicit)
        print("Selected symbols:", selected_symbols_exp)
        print("Prioritized gainers in selection:", prioritized_list_exp) # Should be empty يجب أن تكون فارغة
    else:
        print("\nCannot run examples because CCXT exchange initialization failed.")

